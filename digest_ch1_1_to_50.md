# 내용 정리

## Ch1

### lesson2
- プログラムは main の初めから実行される。
- 命令文の終わりはセミコロン。
- 文字列は " " で囲む。
- 表示するには cout << [何か]; とする。
- 改行するときは cout << endl; とする。

### lesson3
- 掛け算にはアスタリスク（*）、割り算にはスラッシュ（/）を使う。
- 余りにはパーセント記号（%）を使う。
- 演算の優先順位は常識的。

### lesson5
- 変数は宣言してから使う。
- 変数へは、= を使って値を入れる。

### lesson6
- コメントは // に続けるか、/* */ で囲む。
- 変数には宣言時に値を入れることができる。
- 変数の値を変えるには、+=, ++ などの演算子を使う。
- a = a * 5 + 2; なども、方程式ではなく、代入である。

### lesson7 :: 関数
- 関数は引数と戻り値を持っている。
- 関数は定義しなければ使えない。

### lesson8 :: void
- 戻り値のいらない時は、戻り値の型を void にする。
- 引数のいらないときは、カッコの中を空にする。
- 関数には必ずカッコがいる。

### lesson9 :: グローバル変数
- 関数の外で宣言した変数は、それ以降に書かれた関数全てで使える。
- 関数の中で宣言した変数は、その関数内でしか使えない。
- 関数の中で宣言した変数は、関数が終わると破棄される。

### lesson10 :: 値の入力
- 値の入力には、その値を入れる変数が必要。
- 値の入力は cin >> [変数]; とする。

### lesson11 :: 条件分岐
- 条件分岐の書式は if(<条件>){ <実行文１> } else{ <実行文２> } 。
- else 文はなくてもよい。
- <条件>用の演算子がある。

### lesson12 :: もっと条件分岐
- if 文は変数などがある値をとったときの処理を決める。
- **ifは 1文なら囲まなくて良い。**

### lesson13 :: さらに条件分岐
- 条件文は数値でもよく、０は偽、０でないときは真となる。
- 条件式を数値として使うこともでき、真は１、偽は０となる。
- **true == 1(falseではない数), false == 0**

### lesson14 :: ループの仕方
- for(i = 0; i < [回数]; i++){ ... } でループになる。
- **繰り返すものが1ぶんなら{}はなくても構いません。**

### lesson15 :: 配列変数
- int a[<個数>]; で <個数> 個の変数が作れる。
- a[0], a[1], ... という風に使う。
- カッコ内の数字は０から始まる。
- **配列変数を宣言するときには [ ] の中に変数は入れられません。**

### lesson17 :: forの書式
- for の書式は for(<初期化式>; <条件式>; <ループ式>)<実行文> である。
- 条件式は初期化後すぐにも評価される。
- 省略できるパラメータは省略できる。
- **先ず、初期化式を行って、条件式を評価し、条件が真ならば実行文を実行します。そして、実行文が終わるとループ式を行って、再度条件式を評価します。その繰り返しを行うのが for 文の真の機能なのです。**

### lesson18 :: もうひとつのループ
- while(<条件式>)<実行文> でループになる。
- while は for(; <条件式>;) と同じ。
- 条件の判定はループの初めに判定される。
- **while は for の初期化式、ループ式を省略したものと全く同じになります。**
- do-while を使えば、条件はループの終わりに判定される。

### lesson19 :: ループの強制終了
- break を使えばループを抜けられる。
- continue を使えば実行文の終わりに飛べる。

### lesson20 :: 他条件分岐
- switch(<式>){ <分岐> } を使うと多条件分岐になる。
- <式> が case <値>: で示す値のとき、そこへ飛ぶ。
- それ以外は default: に飛ぶ。
- 終わるには break を使う。

### lesson21 :: ビットとバイト
- １ビットは０か１。
- １バイトは８ビット。
- 操作、記憶する際の最小単位はバイト。
- 変数には大きさがある。
- (<型>) を前に付けると型を変更できる。

### lesson22 :: 文字とは
- **文字は通し番号で扱う**
- 通し番号は文字コードと呼ばれる
- 半角文字は１バイト、全角文字は２バイト

### lesson23 :: 文字列の扱い方
- 文字列は文字コードの羅列で表す。
- 文字列の終わりには０（ヌルターミネータ）を付ける。
- **文字列は char 型の配列変数に入れる。**
- 文字列は配列変数の名前で扱う。

### lesson24 :: 文字列をいじろう
- strlen で、文字列の長さを取得できる。
- sprintf で、文字列を編集できる。

| 記号 | %d | %x | %f | %c | %s |
| --- | --- | --- | --- | --- | --- |
| パーツ | 整数 | １６進数 | 小数 | １文字 | 文字列 |

関数名	  |        引数	                        | 機能 
------- | ---------------------------------  | --------------------------------------------------------------------------
strcpy  |	第１引数：容器 <br> 第２引数：文字列    | 第２引数の文字列を第１引数にコピーします。
strcat  |	文字列を２つ	                       | 第２引数の文字列を第１引数に追加します。第１引数の容量をオーバーしないよう気を付けて下さい。
strcmp  |	文字列を２つ	                       | 文字列の比較を行います。等しいときは０を返します。文字列を直接 == で比較することはできないので注意して下さい。
strchr  |	第１引数：文字列 <br> 第２引数：文字    | 指定した文字列の中で、指定した文字が最初に現れるアドレスを返します。見つからなければ NULL というものを返します。
strrchr	| 第１引数：文字列 <br> 第２引数：文字    | 指定した文字列の中で、指定した文字が最後に現れるアドレスを返します。見つからなければ NULL というものを返します。

### lesson26 :: プロトタイプ
- 関数のプロトタイプを書けば、定義を後ろに回すことができる。
- 関数のプロトタイプは関数の中身を書かないだけのもの。 
- build = compile(プログラムを実行ファイルの前段階のファイルに) + link(そのファイルたちを集めて一つの実行ファイルに)

### lesson27 :: インクルード
- #include を使えば、別のファイルを埋め込むことができる。
- ファイル名を < > で囲めば設定されたフォルダの、" " で囲めば今のフォルダのファイルになる。
- ファイルの先頭でインクルードするファイルをヘッダーファイルと言う。

### lesson28 :: マクロの手始め
- #define <マクロ名> <差し込むテキスト>
- マクロはテキストを差し込むもの。
- マクロは引数もとれる。

### lesson29 :: マクロの活用法
- 頻出するものをマクロで１つにまとめ、さらに改造を容易にできる。
- マクロで数値を意味のある文字に置き換えられる。

### lesson30 :: マクロの書式
- マクロ名と差し込むテキストとを分けるものは「空白」。
- カッコの終わりもマクロ名と差し込むテキストの境界になる。
- **演算子の優先順位を無視した書き方は厳禁。**
- 改行したい時は行の終わりに \ を付ける。

### lesson31 :: メモリとアドレス
- メモリは使用中のデータを置いておくところ。
- メモリ上の位置をアドレスという。
- アドレスは普通の変数は前に & を付けて、配列変数と関数は名前だけで取得できる。
- **アドレスは何の変哲もないごく普通の数値なのです。**

### lesson32 :: ポインタ天国
- ポインタはアドレスを格納するための変数。
- ある <型> のアドレスを格納するポインタはその <型> に * を付けた型で宣言する。

```c++
  char a;
  char* p;

  p = &a;
```
- 　p がポインタです。char の後に * の付いた型名になっています。これは char 型の変数のアドレスを入れられる

### lesson33 :: ポインタ天国2
- アドレスに * をつけると、そこのメモリを扱える。

### lesson34 :: ポインタ天国3
- **引数は、新たに変数が作られ、それに値が代入されるという仕組み。**
- 引数をポインタにすると別の関数の内部変数を操作できる。

```c++
#include <iostream>

using namespace std;

void ChangeToShohwa(int *x)
{
  if(1926 < *x && *x < 1989)
    *x -= 1925;
  else
    *x = 0;
}

void Shohwa()
{
  int nYear;

  cout << "西暦を入力してください。";
  cin >> nYear;

  ChangeToShohwa(&nYear);
  if(nYear)
    cout << "その年は昭和" << nYear << " 年です。" << endl;
  else
    cout << "その年は昭和ではありません。" << endl;
}

int main()
{
  Shohwa();
  Shohwa();
  return 0;
}
```

### lesson35 :: 配列再考
- 配列変数は、メモリ上に連続して存在している。
- 配列変数を引数にとるときは、配列変数のアドレスを渡し、ポインタで受ける。
- ポインタも配列変数と同じく [ ] で各要素を参照できる。
- `void func(int array[]) === void func(int* array)`

### lesson36 :: 配列再再考
- 配列変数はメモリ上に確かに連続して存在している。
- 配列変数名は確かに配列の先頭アドレスを指すことができる。
- ポインタを使えば、確かに配列変数を受け渡すことができる。

### lesson37 :: 参照
- 「参照」を使えば、& や * を使わなくても変数を参照できる。
- 参照は型名に & を付けた型で定義する。
- 参照は必ず初期化しなければならない。
- 参照は参照する変数を途中から変更することはできない。
- **先ず、参照は、引数でないときは、必ず初期化しなくてはなりません**
- 参照する変数を途中で変更することもできません。

```c++

#include <iostream>

using namespace std;

int main()
{
  int a;
  int &r = a;

  a = 0;
  cout << "a = " << a << endl
  << "r = " << r << endl << endl;

  r = 100;
  cout << "a = " << a << endl
  << "r = " << r << endl << endl;

  cout << "&a = " << &a << endl
  << "&r = " << &r << endl;
  return 0;
}

```

これは、上で書いたポインタによる参照を簡便化するために使います。つまり、

```c++

void Zero(int& r)
{
    r = 0;
}
    .
    .
    .
int a;
Zero(a);

```
のように使うのが普通です。

### lesson38 :: 参照のしくみ
- 参照は変数（ポインタ）の一種である。
- 参照はポインタと同じように、アドレスを使って変数を参照している。
- 「参照も変数だよ。ポインタと同じようなものだよ」

### lesson39 :: 1 + 1 = 5??
- アドレスの計算は、その型の大きさに左右される。
- アドレスの計算は、加減算しかできない。

### lesson40 :: さらなる計算
- \* と [ ] は同じ演算効果を持つ演算子である。

```c++

#include <cstdio>

using namespace std;

int strlen(char str[])
{
  char *p;
  for(p=str; *p ; p++);
  return p - str;
}

void DispLength(char str[])
{
  printf("文字列「%s」の長さは%dバイトです。\n",str,strlen(str));
}

int main()
{
  DispLength("ほめ殺し");
  DispLength("嘘つきは泥棒のはじまり");
  DispLength("");

  return 0;
}

```

### lesson41 :: 変えてくれるな
- 定数は値を変更できない。

### lesson42 :: 変えてくれるな2
- const は、定数を使いたいときに自由に使うことができる。
- const の書式は `const <型> <名前> = <初期値>;` or  `<型> const <名前> = <初期値>;`。
- ポインタを定数にする場合は <型> *const <名前> = <初期値>; 。

```c++

const char *p;
とすると、参照先が定数になります。p は定数になりません。p を定数にしたい場合は、

char *const p = &a;

```

### lesson43 :: ?:???

- 条件演算子 ?: を使うと、条件によって違う値を表現することができる。
- 条件演算子の書式は <条件式> ? <真の場合> : <偽の場合> 。

> 　何やら変な演算子ですね。これは３項演算子で、３つのパラメータをとります。
代入演算子 = では、右辺と左辺の２つのパラメータをとるので２項演算子、
インクリメント演算子 ++ では、変数１つをパラメータにとるので単項演算子と呼ばれます。
３項演算子はこの条件演算子だけです。

### lesson44 :: いろんな計算を
- 小数の型は精度の違う float 型、double 型、long double 型の３種類ある。
- 演算は double 型で行うのが基本。
- 三角関数などの関数は math.h で宣言されている。

### lesson45 :: 2進数と16進数
- １６進数なら２進数を意識したプログラムが組みやすい。
- １６進数では０～９、Ａ～Ｆの１６個の「数字」を使う。
- １６進数を表現するときは、頭に 0x を付ける。

### lesson46 :: ビットでいじろう
- **ビット演算: AND OR XOR NOT Bitshift**
- **ビット演算子は優先順位が低い。** => カッコを積極的に利用しよう。
- ＡＮＤ（論理積）はそれぞれのビットについて、両方とも１のときは１を、それ以外のときは０を出力する。
- ＡＮＤの演算子は & である。
- **ＡＮＤは特定のビットを取り出すのに使う。（マスキング）**

### lesson47 :: ビットでいじろう２
- ＯＲ（論理和）はそれぞれのビットについて、どちらかが１のときは１を、そうでないときは０を出力する。
- ＯＲの演算子は | である。
- **ＯＲは特定のビットを１にするのに使う。(ビットの合成)**
- ＸＯＲ（排他的論理和）はそれぞれのビットについて、両方が同じ時は０を、異なるときは１を出力する。
- ＸＯＲの演算子は ^ である。
- **ＸＯＲは特定のビットを反転させるのに使う。**

```c++

たとえば、２人用のゲームでプレイヤーの反転を行うときなどがいい例です。先ずプレイヤーを fPlayer という変数で表し、０を１Ｐ、１を２Ｐとします。するとプレイヤーの反転は

fPlayer ^= 1;
でできるわけです。これは結果だけを見れば

fPlayer = 1 - fPlayer;
と同じですが、ＸＯＲを使った方が効率的です。

```

### lesson48 :: ビットでいじろう3
- ＮＯＴ（論理否定）は全ビットを反転する。
- ＮＯＴの演算子は ~ である。
- ビットシフトはビットを左右にずらすことである。
- ビットシフトの演算子は >> と << である。
- ビットシフトは２の累乗での乗除に利用できる。

> このように、ＮＯＴは普通ＡＮＤと組み合わせて、特定のビットを０にするときに使います
もちろんＡＮＤ単独でもできますが、ＮＯＴと組み合わせて使う方が便利で分かりやすいときがあります。
このＮＯＴとＡＮＤを組み合わせた計算を、特にＮＡＮＤと呼ぶことがあります。


```c++

// #define BIT(x) (1 << (x))

というマクロを作れば、BIT(0) で第０ビットのみが、BIT(4) で第４ビットのみが１になった値を表現することができます。

　また、for 文で

unsigned int i, x = 105054;
for(i = 1; i; i <<=1)
{
    if(x & i)...
    else...
}
のようにすると、第０ビットが１かどうか、第１ビットが１かどうか...
と、ビットスキャンを行うことができます。

```

### lesson49 :: ビットでフラグ
- フラグはＯＲで繋ぐ。
- フラグはＡＮＤ（もしくはＮＡＮＤ）で判定する。
- ビット演算に使用する変数は符号無しにする。

```c++

// Flag1.cpp
#include <iostream.h>
#include <ctype.h>

// #define BIT(num)                 ((unsigned int)1 << (num))
// #define SCEX_COPY                0
// #define SCEX_ADD                 BIT(0)
// #define SCEX_TRIM                BIT(1)
// #define SCEX_UPPER               BIT(2)
// #define SCEX_LOWER               BIT(3)

void strcpy_ex(char* pszDest, const char* pszSource, unsigned int flags);

int main()
{
    char buf[512];

    strcpy_ex(buf, "The ", SCEX_COPY);
    strcpy_ex(buf, "\t\t Country Is Called  ", SCEX_ADD | SCEX_TRIM | SCEX_LOWER);
    strcpy_ex(buf, " usa.", SCEX_ADD | SCEX_UPPER);
    cout << buf;

    return 0;
}

// 文字列をコピーする関数
void strcpy_ex(char* pszDest, const char* pszSource, unsigned int flags)
{
    if(flags & SCEX_ADD)
        for(; *pszDest; pszDest++);
    if(flags & SCEX_TRIM)
        for(; *pszSource == ' ' || *pszSource == '\t'; pszSource++);

    for(; *pszSource; pszSource++, pszDest++)
    {
        *pszDest = (flags & SCEX_UPPER) ? toupper((unsigned char)*pszSource) :
                   (flags & SCEX_LOWER) ? tolower((unsigned char)*pszSource) :
                   *pszSource;
    }
    pszDest--;
    if(flags & SCEX_TRIM)
        for(; *pszDest == ' ' || *pszDest == '\t'; pszDest--);
    pszDest[1] = '\0';
}

```

> 　ビット演算をするときは、変数を unsigned（符号無し）にします。
というのも、**負の値に対するビット演算の結果は、環境に依存する可能性**があるからです。
まぁ、難しいことは抜きにして、ビット演算をする変数は符号無しにする、と覚えておいて下さい。

### lesson50 :: 命名法
- やたらと短い名前はなるべく避け、意味を持った名前を付ける。
- 変数の型や種類がある程度分かるようにする。
- **マクロはなるべく全て大文字にする。**
- 長い名前は、単語の区切りが分かるようにする。
- さて、命名法についてはこれで終わりです。命名法で一番大切なのは「分かりやすい」ことです。それは「バグの軽減」に繋がります。

<a href="https://www.youtube.com/watch?v=va5rf20Un24
" target="_blank"><img src="http://anizoo.up.n.seesaa.net/anizoo/image/otteragressive.jpg?d=a0" 
alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10" /></a>