<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=x-euc-jp">
<title>ロベールのＣ＋＋教室 - 第７３章 借りたら返す３ -</title>
</head>
<body bgcolor=white>

<center>
<font size=6>第７３章　借りたら返す３</font>
</center>
<hr>

<p>　前２回でメモリの動的確保についてやってきました。では、動的確保はどのようなときに使えばいいのでしょうか？　今回はそういうお話です。</p>

<hr>

<p>　では、今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>動的確保を使うとサイズが自由な配列が作れる。</li>
<li>動的確保を使うと巨大な配列が安全に作れる。</li>
<li>動的確保を使うと変数の寿命を制御できる。</li>
</ul>
</font>
<p><br></p>

<p>　では、いってみましょう。</p>

<hr>

<p>　前回、フィボナッチ数列を作りました。そのとき、配列の動的確保を行いましたね。このときの配列のサイズは、入力した数値によって変わってきました。これが、動的確保の第１の利用法です。</p>

<p>　つまり、<font size=+1 color=red>メモリの動的確保を使うと、配列のサイズを実行中に決めることができる</font>のです。こういった配列を可変長配列と呼びます。</p>

<p>　これはとても便利です。今までなら、フィボナッチ数列を計算し、これを保存しておくとしても、保存できる個数は確保した配列のサイズ以内に限定されてしまいました。何と、この制限がなくなるのです。もちろん、メモリがなくなってしまえば確保できなくなってしまいますが。</p>

<hr>

<p>　次は、<a href="cpp01061.html" target="main">第６１章</a>で話した<font color=red>スタックオーバーフロー</font>に関する話です。</p>

<p>　自動変数で巨大な配列変数を作ると自動変数用の領域をあふれてしまい、スタックオーバーフローというエラーが起こってしまいます。スタックオーバーフローになると、そのあふれた先にたまたまあったメモリ領域を使うことになります。そこに書き込みを行うと、たまたまそこにあった変数などの値を変えてしまいます。</p>

<p>　スタックオーバーフローが起こるとすぐにエラーが起こるわけではありません。こうして別の変数の値を変えて、それが原因でたまたま何か変な動作が起きて、そして初めてエラーが発生するのです。もしくは、書き込んではいけない領域に書き込んでしまい、エラー終了することもあるでしょう。ですが、このとき<font color=red>たまたまきちんと動けばスタックオーバーフローに気付くことはないでしょう</font>。</p>

<p>　このため、<font size=+3 color=red>スタックオーバーフローはプログラムのバグにおいて３本の指に入る最悪なバグです。</font></p>

<p>　このような大きな配列を作るときは動的に確保します。大きな配列なのでメモリが足りないときもあるでしょう。そういうときもプログラムの起動はでき、その時の動作をきちんと記述することができます。</p>

<p>　ここでグローバル変数として確保してしまうと、<font color=red>プログラムの起動自体ができなくなってしまいます</font>。グローバル変数のメモリを確保するのは、プログラムを起動するその時だからです。巨大な配列を必要とする機能がそのソフトの単なる１機能な時であっても、グローバル変数にしてしまうと他の全ての機能も利用できなくなってしまいます。これは最早<font color=red>バグ</font>です。</p>

<p>　このように、<font color=red>メモリの動的確保を使えば大きな配列も安全に作成することができる</font>のです。</p>

<hr>

<p>　最後は寿命の話です。</p>

<p>　<a href="cpp01068.html" target="main">第６８章</a>で話したように、変数には寿命があります。では、動的に確保したメモリの寿命はどうなるのでしょうか？</p>

<p>　これは簡単ですね。new してから delete されるまでです。つまり、delete されるまではメモリの内容は保証されるわけですね。</p>

<p>　このことから分かるとおり、<font color=red>new で確保したメモリの寿命はブロックには左右されません</font>。ブロックを超えた自由な寿命を持つわけです。delete するタイミングを調整すれば、寿命をコントロールできるわけです。</p>

<p>　このように、<font color=red>ブロックを超えた自由な寿命を持たせたいときに、メモリの動的確保が利用できる</font>のです。</p>

<p>　ただし、この場合は注意しないとメモリリークが起こる可能性があります。<font color=red>こういった使い方を行う場合はメモリリークに十分注意して下さい。</font></p>

<hr>

<p>　今回はこれだけです。今までの反動でしょうか、短いですね。</p>

<p>　それでは、今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>動的確保を使うとサイズが自由な配列が作れる。</li>
<li>動的確保を使うと巨大な配列が安全に作れる。</li>
<li>動的確保を使うと変数の寿命を制御できる。</li>
</ul>
</font>
<p><br></p>

<p>　３回なかなか重要な事をしてしんどかったので、次回はとても簡単な章にします。息抜きにどうぞ。</p>

<hr>

<p align=right><a href="cpp01072.html" target="main">第７２章　借りたら返す２</a> | <a href="cpp01074.html" target="main">第７４章　もっとロジカルに</a></p>
<p align=right><font size=-1><i>Last update was done on 2000.7.29</i></font></p>

<p align=right><font size=-1><i>この講座の著作権は<a href="http://www1.kcn.ne.jp/~robe/">ロベール</a>が保有しています</i></font></p>

</body>
</html>
