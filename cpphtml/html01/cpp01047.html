<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=x-euc-jp">
<title>ロベールのＣ＋＋教室 - 第４７章 ビットでいじろう２ -</title>
</head>
<body bgcolor=white>

<center>
<font size=6>第４７章　ビットでいじろう２</font>
</center>
<hr>

<p>　今回も前回の続き、ビット演算について話します。今回はそのうちのＯＲとＸＯＲについて話したいと思います。</p>

<hr>

<p>　今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>ＯＲ（論理和）はそれぞれのビットについて、どちらかが１のときは１を、そうでないときは０を出力する。</li>
<li>ＯＲの演算子は | である。</li>
<li>ＯＲは特定のビットを１にするのに使う。</li>
<li>ＸＯＲ（排他的論理和）はそれぞれのビットについて、両方が同じ時は０を、異なるときは１を出力する。</li>
<li>ＸＯＲの演算子は ^ である。</li>
<li>ＸＯＲは特定のビットを反転させるのに使う。</li>
</ul>
</font>
<p><br></p>

<p>　では、いってみましょう。</p>

<hr>

<p>　早速<font color=red>ＯＲ（論理和）</font>についての話に入りましょう。Ｃ／Ｃ＋＋言語の<font color=red>演算子は |</font> で、２つの数値から、１つの演算結果を導き出します。先ずは計算例を見てみましょう。（数値は２進数です。）</p>

<pre>　　００１１
｜）０１０１
――――――
　　０１１１</pre>

<p>　つまり、<font color=red>どちらかが１のところは１、それ以外は０</font>になります。これがＯＲです。</p>

<p>　青が０、赤が１とすると、こんな感じになります。</p>

<table align=center>
<tr>
<td><img src="images/0104601.gif"></td>
<td valign=center>｜</td>
<td><img src="images/0104602.gif"></td>
<td valign=center>＝</td>
<td><img src="images/0104701.gif"></td>
</tr>
</table>

<p>　前回言ったとおり、ビット演算は論理演算を基本としています。ＯＲは「もしくは」という言葉の意味を考えれば、その演算方法も簡単に覚えることができるでしょう。</p>

<hr>

<p>　さて、次はＯＲの利用法について話しましょう。</p>

<p>　先ずは、下の計算を見て下さい。</p>

<pre>　　０１１１１０１０
｜）００００１１１１
――――――――――
　　０１１１１１１１</pre>

<p>　この計算をＡ＆Ｂ＝Ｃとおきます。これを見れば分かるとおり、Ｂで１であるビットはＣでも全て１になっています。そして、Ｂで０であるビットはＡのものがそのままＣに現れています。つまり、<font color=red>Ａの下位４ビットが１にされた</font>ということになります。</p>

<p>　つまり、<font color=red>１にしたいところのビットを１にした値を使えば、ＯＲをとることによって特定のビットを１にすることができる</font>のです。これは<font color=red>２つの値を合成できる</font>とも言い換えられます。ＯＲはもっぱらこのビット合成に使われます。</p>

<p>　ＡＮＤとＯＲを使うと、ビット単位で０と１の変換、そして判定ができます。これはビット演算の中でも最も重要な部分なので、これについては後の章で詳しく話すことにします。</p>

<hr>

<p>　次は<font color=red>ＸＯＲ（排他的論理和）</font>です。Ｃ／Ｃ＋＋言語の<font color=red>演算子は ^</font> で、２つの数値から、１つの演算結果を導き出します。^ はＢＡＳＩＣでは累乗の演算子なので、ＢＡＳＩＣからＣに入った人は混乱しないように注意です。で、どんなところが「排他的」なのか気になる名前ですが、それはともかく先ずは計算例を見てみましょう。（数値は２進数です。）</p>

<pre>　　００１１
＾）０１０１
――――――
　　０１１０</pre>

<p>　つまり、<font color=red>両方のビットが同じところは０、異なるところは１</font>になります。これがＸＯＲです。</p>

<p>　青が０、赤が１とすると、こんな感じになります。</p>

<table align=center>
<tr>
<td><img src="images/0104601.gif"></td>
<td valign=center>＾</td>
<td><img src="images/0104602.gif"></td>
<td valign=center>＝</td>
<td><img src="images/0104702.gif"></td>
</tr>
</table>

<p>　「排他的論理和」の「排他的」というのは、この図を見ればわかるでしょう。ＯＲのうち、ＡＮＤの部分を「排他」しているわけです。まぁ何はともかく、同じだと消えるということを覚えておいて下さい。</p>

<hr>

<p>　さて、次はＸＯＲの利用法について話しましょう。</p>

<p>　先ずは、下の計算を見て下さい。</p>

<pre>　　０１１１１０１０
＾）００００１１１１
――――――――――
　　０１１１０１０１</pre>

<p>　この計算をやはりＡ＆Ｂ＝Ｃとおきます。これを見れば分かるとおり、Ｂで１であるビットはＣではＡの逆になっています。そして、Ｂで０であるビットはＡのものがそのままＣに現れています。つまり、<font color=red>Ａの下位４ビットの０と１が反転した</font>ということになります。</p>

<p>　つまり、<font color=red>反転したいところのビットを１にした値を使えば、ＸＯＲをとることによって特定のビットを反転することができる</font>のです。ＸＯＲはもっぱらこのビット反転に使われます。</p>

<p>　たとえば、２人用のゲームでプレイヤーの反転を行うときなどがいい例です。先ずプレイヤーを fPlayer という変数で表し、０を１Ｐ、１を２Ｐとします。するとプレイヤーの反転は</p>

<pre>fPlayer ^= 1;</pre>

<p>でできるわけです。これは結果だけを見れば</p>

<pre>fPlayer = 1 - fPlayer;</pre>

<p>と同じですが、ＸＯＲを使った方が効率的です。</p>

<hr>

<p>　今回はこれで終わりです。では今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>ＯＲ（論理和）はそれぞれのビットについて、どちらかが１のときは１を、そうでないときは０を出力する。</li>
<li>ＯＲの演算子は | である。</li>
<li>ＯＲは特定のビットを１にするのに使う。</li>
<li>ＸＯＲ（排他的論理和）はそれぞれのビットについて、両方が同じ時は０を、異なるときは１を出力する。</li>
<li>ＸＯＲの演算子は ^ である。</li>
<li>ＸＯＲは特定のビットを反転させるのに使う。</li>
</ul>
</font>
<p><br></p>

<p>　次回はＮＯＴとビットシフトについて話します。それでは。</p>

<hr>

<p align=right><a href="cpp01046.html" target="main">第４６章　ビットでいじろう</a> | <a href="cpp01048.html" target="main">第４８章　ビットでいじろう３</a></p>
<p align=right><font size=-1><i>Last update was done on 2000.1.18</i></font></p>

<p align=right><font size=-1><i>この講座の著作権は<a href="http://www1.kcn.ne.jp/~robe/">ロベール</a>が保有しています</i></font></p>

</body>
</html>
