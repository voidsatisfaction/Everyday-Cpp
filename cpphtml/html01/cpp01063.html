<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=x-euc-jp">
<title>ロベールのＣ＋＋教室 - 第６３章 参照するな -</title>
</head>
<body bgcolor=white>

<center>
<font size=6>第６３章　参照するな</font>
</center>
<hr>

<p>　ポインタというのは、参照先があって初めて参照できます。しかし、あるポインタが参照できるか、できないかが、実際に参照してみるまで分からないというのは困りものです。かといって、いちいちフラグ（<a href="cpp01049.html" target="main">第４９章</a>参照）用の変数を別に作るのも面倒です。今回は、そういう話です。</p>

<hr>

<p>　以下が、今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>ヌルポインタはどんなオブジェクトや関数のアドレスと比較しても等しくならない。</li>
<li>ヌルポインタはソース上では 0 である。</li>
<li>ヌルポインタの実際の値は０とは限らない。</li>
<li>ヌルポインタには NULL マクロを使える。</li>
<li>ヌルポインタはフラグ代わりに使える</li>
</ul>
</font>
<p><br></p>

<p>　では、いってみましょう。</p>

<hr>

<p>　ポインタは必ず参照先を指定してから参照しなければなりません。しかし、実際にはポインタを宣言してすぐに参照先を指定するような場合ばかりではありません。</p>

<p>　<font color=red>参照先をまだ指定していない段階でこのポインタが使われる</font>恐れがあるときは、そのポインタが使えるかどうかを判別して、分岐処理を行う必要があるでしょう。</p>

<p>　しかし、初期化していない変数には何が入っているか分かりません。たまたま参照できるようなアドレスが入っている場合もあるので、実際に参照してみてエラーが出るかどうかで判定することもできません。</p>

<p>　かといって、「こんなアドレスはないだろうなぁ」という適当な値で初期化しても、もしかしたらそういうアドレスがある可能性もあり、確実ではないです。</p>

<p>　そこで、<font color=red>「どんなオブジェクトや関数のアドレスと比較しても等しくならないことが保証されているアドレス」</font>というものが存在します。そのようなアドレスを示すポインタを<font color=red>ヌルポインタ</font>と呼びます。プログラム上得られうる全ての有効なアドレスと等しくならないわけですね。このヌルポインタで初期化しておけば、ヌルポインタかどうかの判定で、ポインタの使用・未使用が判別できるわけです。</p>

<p>　ヌルポインタの値は<font color=red>ソース上では 0</font> です。しかし、<font color=red>実際の値が０であるという保証はありません</font>。</p>

<pre>例）char* p = <font color=red>0</font>;</pre>

<p>　つまり、<font color=red>0</font> とは単に<font color=red>ヌルポインタを表す記号</font>な訳です。</p>

<hr>

<p>　例えば、次のような文があったとします。</p>

<pre>char* pNull = 0;</pre>

<p>　さて、pNull が 0 で初期化されています。ヌルポインタの値は<font color=red>ソース上では 0</font> です。つまり、pNull はヌルポインタになりました。アドレスが pNull と等しくなるようなオブジェクトは存在しないわけです。</p>

<p>　しかし、pNull に入っている値も０であるとは限りません。これは、<a href="../htmlword/words023.html" target="words">環境に依存します</a>。</p>

<p>　ちなみに、大体の環境ではアドレスも０になるでしょう。しかし、<font color=red>０にならない環境もある</font>ということは、きちんと頭に入れておく必要があります。実は、型が違えばアドレスの値が変わるような環境もあるそうです。それを踏まえた上で、「対象とする環境では必ず０になるから、０であるとしてプログラムを組もう」というのは、許されることかもしれません。普通にＷｉｎｄｏｗｓプログラムをする分には、気にすることはないでしょう。</p>

<p>　Ｃ／Ｃ＋＋言語はどんな環境で使われるか分かりません。でも、どんな環境で使われたとしてもヌルポインタは０ですむようになっているわけです。ヌルポインタの値が０でないことも想定したプログラムは、どんな環境でもきちんと動くわけです。</p>

<hr>

<p>　さて、ヌルポインタには、<font color=red>ヌルポインタを示すマクロ</font>が用意されています。それは<a href="cpp01051.html" target="main">第５１章</a>で出てきた <font color=red>NULL</font> です。</p>

<p>　NULL はプログラムを読みやすくするために使うわけであり、NULL が 0 に置き換わるとしても、ただの 0 の代わりとして使うわけにはいきません。間違っても</p>

<pre>int i;
for(i = NULL; i < 9; i++)</pre>

<p>などということは、絶対にしないようにして下さい。（まぁ、しないとは思いますけど。）</p>

<p>　それに、NULL は ((void*)0) と定義されていることもあるそうです。ポインタ以外の変数への代入ができないようにしているのでしょう。（この形にはいろいろ批判があります。NULL マクロ自体にもいろいろ批判があります。が、詳しいことは専門書、別ＨＰなどに任せます。void* についても、第３部で話します。）ＶＣ＋＋では、Ｃ言語を使うときは ((void*)0) 、Ｃ＋＋を使うときは 0 となっているようです。</p>

<hr>

<p>　ヌルポインタは「どんなオブジェクトや関数のアドレスと比較しても等しくならないポインタ」です。NULL か、NULL でないかで処理を分けることができるわけですが、これにはいろいろな<font color=red>意味</font>を持たせることができます。</p>

<p>　例えば、以下のようなことができます。</p>

<ul>
<li>アドレスを返すような関数では、関数が失敗したときは NULL を返すようにする。</li>
<li>NULL を渡すと何らかの<a href="../htmlword/words024.html" target="words">デフォルト</a>の処理をする関数を作る。</li>
<li>NULL を渡すと、そのパラメータを無視する。</li>
</ul>

<p>　実際に、fopen では関数が失敗すると NULL が返ってきましたし、strtok という関数では NULL を渡すと特別な処理をするようになっています。</p>

<p>　このように、<font color=red>ヌルポインタはフラグ代わりに使用できる</font>わけです。</p>

<hr>

<p>　今回はこれでおわりです。では、要点を見てみましょう。</p>

<font size=+2 color=red>
<ul>
<li>ヌルポインタはどんなオブジェクトや関数のアドレスと比較しても等しくならない。</li>
<li>ヌルポインタはソース上では 0 である。</li>
<li>ヌルポインタの実際の値は０とは限らない。</li>
<li>ヌルポインタには NULL マクロを使える。</li>
<li>ヌルポインタはフラグ代わりに使える</li>
</ul>
</font>
<p><br></p>

<p>　地味な章でしたが、たまにはこんなのもいいでしょう。では、次回まで。</p>

<hr>

<p align=right><a href="cpp01062.html" target="main">第６２章　多次元配列２</a> | <a href="cpp01064.html" target="main">第６４章　同姓同名</a></p>
<p align=right><font size=-1><i>Last update was done on 2000.7.26</i></font></p>

<p align=right><font size=-1><i>この講座の著作権は<a href="http://www1.kcn.ne.jp/~robe/">ロベール</a>が保有しています</i></font></p>

</body>
</html>
