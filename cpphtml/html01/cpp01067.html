<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=x-euc-jp">
<title>ロベールのＣ＋＋教室 - 第６７章 静的内部変数 -</title>
</head>
<body bgcolor=white>

<center>
<font size=6>第６７章　静的内部変数</font>
</center>
<hr>

<p>　<a href="cpp01065.html" target="main">第６５章</a>で「静的」という言葉を説明しました。しかし、この説明は正確ではないのです。なぜなら、内部変数も静的にすることができるからです。今回はその方法について話します。</p>

<hr>

<p>　今回の要点は以下の通りです。</p>

<font size=+2 color=red>
<ul>
<li>static をつければ、内部変数も静的になる。</li>
<li>static の付いていないものは自動変数と呼ばれる。</li>
<li>静的変数の初期化は内部変数でも１度のみ。</li>
<li>静的変数は初期化されなければ０で初期化される。</li>
<li>静的変数は関数を抜けても値が保存される。</li>
</ul>
</font>
<p><br></p>

<p>　では、いってみましょう。</p>

<hr>

<p>　先ず、<font color=red>静的変数</font>の定義を確認しましょう。静的変数とは、<font color=red>「プログラムが実行される前（プログラムがメモリ上にロードされたときに）位置が決まっている変数」</font>のことです。</p>

<p>　そして、静的でないデータの例として、引数と内部変数を挙げました。でも、内部変数は静的にすることができるのです。</p>

<p>　方法は簡単です。<font color=red>変数の型に static を加えるだけです。これだけで内部変数は静的変数になります。</font>普通は static は先頭に書きますが、別にどこに書いても間違いではありません。</p>

<pre>例）
void Func()
{
    static int a;
    cout &lt;&lt; &amp;a &lt;&lt; endl;
}</pre>

<p>　一方、静的でない内部変数のことを<font color=red>自動変数</font>と呼びます。</p>

<hr>

<p>　では、プログラムを作って、静的内部変数の動作を調べてみましょう。</p>

<p>　確認点を先に挙げておきます。グローバル変数は静的変数だったので、<a href="cpp01009.html" target="main">第９章</a>で挙げたグローバル変数の特徴の中には、本来は静的変数全体における特徴があるはずです。それを踏まえて、以下のことを確かめてみます。</p>

<ul>
<li>アドレスが常に一定かどうか。</li>
<li>初期化は１回しかされない。</li>
<li>初期化しなければ０で初期化される。</li>
<li>関数を抜けても値は保証される。</li>
</ul>

<p>　では、やってみましょう。</p>

<center><table border=1>
<colgroup><col valign=top><col valign=top></colgroup>
<tbody>

<tr><th>プログラム</th><th>実行結果例</th></tr>

<tr>
<td><a href="cp010671.html" target="_blank">長いので、別ウィンドウでご覧下さい</a></td>

<td><pre>アドレスが常に一定かのチェック
&a = 0x0042A038
&b = 0x0065FD4C
in Sub2
&a = 0x0042A038
&b = 0x0065FCF8
&a = 0x0042A038
&b = 0x0065FD4C

初期化が１回しかされないかのチェック
a = 3
b = 3
a = 4
b = 3

０で初期化されるかのチェック
0,0,0,0
6684068,4366288,4366288,4242892

値が保証されるかのチェック
*pa = 9
*pb = 25637</pre></td>
</tr>

</tbody></table></center>

<p>　順に見ていきましょう。</p>

<p>　先ずは、「アドレスが常に一定か」のチェックです。</p>

<p>　自動変数 b のアドレスは AddressCheck_Sub2 内から呼ぶとアドレスが変わっていますが、静的変数 a のアドレスは常に 0x0042A038 で一定です。<font color=red>アドレスは常に一定</font>のようです。これで、a はきちんと静的な変数になっていることが分かりましたね。</p>

<p>　そして、このアドレスを見ると、自動変数と静的変数では随分アドレスに差があることが分かります。このことも、自動変数と静的変数は別物であるということを示していそうですね。</p>

<p><br></p>

<p>　次は、「初期化が１回しかされないか」のチェックです。</p>

<p>　自動変数 b の値は、１回目も２回目も３でした。これは当たり前ですね。で、一方静的変数 a の値は、１回目は３でしたが、２回目は４になっています。２回目に関数を呼んだときには初期化が行われていないことが分かります。つまり、<font color=red>初期化は１回しか行われない</font>わけです。</p>

<p><br></p>

<p>　次は、「０で初期化されるか」のチェックです。</p>

<p>　自動変数には全部変な値が入っています。値から見るとおそらく何らかのアドレスで、何かで使ったものがメモリ上にそのまま残っているようです。</p>

<p>　一方静的変数には全部０が入っています。このように、<font color=red>初期化を行わなかった場合は、静的変数は０で初期化されます</font>。</p>

<p><br></p>

<p>　最後は、「値が保証されるかのチェック」です。</p>

<p>　先ず、変数に９という値を入れ、それからその変数のアドレスを取得します。<font color=red>int*&amp; というのは int* への参照です。</font>ポインタもただの変数なので、もちろんポインタへの参照も作れます。このようにして、変数のアドレスを呼び出し側に返すわけです。</p>

<p>　で、次に HoldValueCheck_Sub2 関数を呼びます。ここでは関数を呼ぶということと、その中で大きな自動変数を作り０で埋めるということを行っています。この関数を呼ぶことで、メモリを大きく攪乱しているわけです。さらに、その後の cout でも攪乱されますね。</p>

<p>　で、値を表示します。自動変数の参照である *pb の値は、何か変な値になっています。自動変数 b の値は、関数を抜けると保証されないことがよく分かります。</p>

<p>　一方、静的変数の参照である *pa の値は、きちんと９のまま保存されています。これは偶然ではなく、もちろんこういう仕様になっています。このように、<font color=red>静的内部変数は関数を抜けても値が保証されます</font>。</p>

<hr>

<p>　以上のことをまとめると、次のようになります。</p>

<font size=+2 color=red>
<ul>
<li>static をつければ、内部変数も静的になる。</li>
<li>static の付いていないものは自動変数と呼ばれる。</li>
<li>静的変数の初期化は内部変数でも１度のみ。</li>
<li>静的変数は初期化されなければ０で初期化される。</li>
<li>静的変数は関数を抜けても値が保存される。</li>
</ul>
</font>
<p><br></p>

<p>　グローバル変数の特徴と思っていたものは、ほとんどが静的変数の特徴だったことが分かります。グローバル変数は無条件で静的変数になるわけです。</p>

<hr>

<p>　今回はこれで終わりです。どうですか、分かりましたか？</p>

<p>　次回もまた変数についてのお話です。それでは、また次回まで。</p>

<hr>

<p align=right><a href="cpp01066.html" target="main">第６６章　インライン関数</a> | <a href="cpp01068.html" target="main">第６８章　寿命</a></p>
<p align=right><font size=-1><i>Last update was done on 2000.7.28</i></font></p>

<p align=right><font size=-1><i>この講座の著作権は<a href="http://www1.kcn.ne.jp/~robe/">ロベール</a>が保有しています</i></font></p>

</body>
</html>
