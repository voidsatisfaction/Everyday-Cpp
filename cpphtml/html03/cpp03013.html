<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=x-euc-jp">
<title>ロベールのＣ＋＋教室 - 第１３章 精密作業 -</title>
</head>
<body bgcolor=white>

<center>
<font size=6>第１３章　精密作業</font>
</center>
<hr>

<p>　普通、変数はバイト単位で扱います。ビット演算を行っても、結局変数はバイト単位で使わなければいけませんでした。今回は、本当にビット単位で変数を扱うことができる方法を話しましょう。</p>

<hr>

<p>　では、今回の要点です。</p>

<font size=+2 color=red>
<ul>
<li>構造体のメンバ変数の後ろに : &lt;ビット数&gt; を書くと、そのメンバ変数の大きさはそのビット数になる。</li>
<li>ビットフィールドの型は unsigned int か signed int か int のみ。</li>
<li>ビットフィールド全体のサイズは int のサイズか、その倍数に揃えられる。</li>
<li>構造体の一部ででも使用できる。</li>
</ul>
</font>
<p><br></p>

<p>　では、いってみましょう。</p>

<hr>

<p>　今回は西暦２０００年問題の謎を解いてみましょう。</p>

<p>　西暦２０００年問題。それは１９９０年代末に世界を騒がせた問題です。それは、西暦を下２桁で扱っているプログラムが西暦２０００年を西暦１９００年と間違え、誤作動を起こしてしまう可能性がある、という問題でした。</p>

<p>　年を扱うプログラムというのは多岐にわたり、様々なところでプログラムの修正、もしくは使用ソフトの変更などが行われてきました（多分）。その甲斐あってか、実際に問題の起きたケースは非常に少なく、平穏に時が流れていきました（多分）。（気象庁などで全く別の原因の閏年問題が起きましたが。）</p>

<p>　西暦を下２桁で扱っていた理由は「データのサイズが減らせるから」でした。何百万、何千万といったデータを扱えば、１つ１つのデータ量を１バイト減らしただけでも１メガバイト、１０メガバイトとデータが減らせるわけです。今でこそハードディスクは数十ギガバイトが当たり前ですが、昔は記憶媒体のサイズも小さく、また、メモリのサイズも小さく、こういった努力は非常に重要でした（多分）。</p>

<p>　しかし、ここで疑問が残ります。年月日を扱うときに、<font color=red>西暦を下２桁で扱うと本当にデータ量が減らせるのでしょうか？</font>　今回はそれを追求してみます。</p>

<hr>

<p>　先ず、年月日というデータはどのような量なのでしょうか？</p>

<p>　年は、これといって範囲は決まっていません。しかし、コンピュータで扱う以上範囲は設定しなければいけません。とりあえず、西暦を生の値で保存したければ<font color=red>２バイト</font>は必要となります。</p>

<p>　次は月です。月は１〜１２まであり、<font color=red>１バイト</font>の変数に入れられそうです。</p>

<p>　次は日です。日は１〜３１まであり、これも<font color=red>１バイト</font>の変数に入れられそうです。</p>

<p>　ということで、年月日をまともに扱おうとすると<font color=red>４バイト</font>の大きさになることが分かります。</p>

<p>　ここで、年を下２桁で扱おうとするとどうなるでしょうか？　下２桁となると範囲は０〜９９となり、<font color=red>１バイト</font>におさまります。ということで、合計<font color=red>３バイト</font>となり、節約になりました。</p>

<p>　しかし、これでは無理に下２桁にしなくてもいいとは思いませんか？　０〜２５５まで使えるのですから、せめて<font color=red>西暦２０９９年</font>くらいまでは使えるようにしてくれていてもいいじゃないですか。</p>

<p>　となると、<font color=red>まだデータ量を小さくする秘策がありそうです</font>。もう少し、年月日というデータを突き詰めてみましょう。</p>

<hr>

<p>　先ず、月です。月は１〜１２まであります。よく考えてみると、このデータは０〜１５、つまり<font color=red>４ビット</font>で表現できることが分かります。</p>

<p>　次に、日です。日は１〜３１まであります。これもよく考えてみると、このデータは０〜３１、つまり<font color=red>５ビット</font>で表現できることが分かります。</p>

<p>　３バイトよりデータ量を少なくしようとすると、上の２つを足して１バイトと１ビットなのですから、最低でも<font color=red>２バイト</font>は必要でしょう。ということで、<font color=red>残り７ビットに年を入れればいい</font>わけです。</p>

<p>　７ビットで表現できるデータは０〜１２７です。ということは<font color=red>０〜９９なら何とか入ります</font>。ですが、それ以上は中途半端なのでこのあたりでうち切ろうと思います。</p>

<p>　ということで、<font color=red>西暦を下２桁で扱えばデータは２バイトにおさまってしまう</font>わけです。</p>

<p>　この２バイトで収まってしまうところがあの騒ぎの原因になってしまった（多分）ことを考えると、いっそのこと収まらなかった方がよかったのではと思いたくなりますね。</p>

<hr>

<p>　さて、ビット演算でこれらのことを行おうとしてもかなり面倒です。Ｃ／Ｃ＋＋言語にはこれらのことを自動的にしてくれる便利な機能があります。それが<font color=red>ビットフィールド</font>です。</p>

<p>　使い方は簡単です。構造体の宣言をするとき、<font color=red>メンバ変数名の後ろに : &lt;ビット数&gt; を書けばいい</font>だけです。この変数のサイズは<font color=red>そこで指定されたビット数</font>になります。</p>

<p>　まぁ、とりあえず見てみましょう。</p>

<pre>struct BDate
{
    unsigned nYear  : 7;
    unsigned nMonth : 4;
    unsigned nDay   : 5;
};</pre>

<p>　このようにすれば、nYear の大きさは<font color=red>７ビット</font>、nMonth の大きさは<font color=red>４ビット</font>、nDay の大きさは<font color=red>５ビット</font>になります。</p>

<p>　ここで、型を見て下さい。ビット単位で変数を割り当てるのですが、その時型はどうなるのでしょうか？　サイズは自前で決めているのですから、あまり型には意味がないことが分かります。分かっていればいいのは<font color=red>符号付き</font>か<font color=red>符号無し</font>かだけですね。</p>

<p>　ということで、ビットフィールドに使う変数の型は <font color=red>unsigned int, signed int, int</font> に限定されています。ツールによっては制限をなくしているかもしれませんが、これが基本です。</p>

<p>　unsigned int は unsigned と、signed int は signed と略せるので（これはビットフィールドに限ったことではありません）、<font color=red>unsigned か signed を使うと分かりやくてよい</font>でしょう。int と signed int, signed は同じです。signed を int としても別に構わないでしょう。</p>

<p>　これで、西暦２０００年問題は出ますが、年月日を２バイトで扱うことができました。</p>

<p>　しかし、<font color=red>ビットフィールド全体のサイズは強制的に int と同じサイズ、もしくはその倍数にされてしまいます</font>。昔は int のサイズが２バイトでしたのでこれでよかったのですが、今では４バイトになってしまってかえってサイズが増えてしまいますね。</p>

<p>　そして、この年には実際は０〜１２７のデータが入ります。プログラムによっては西暦２０２８年問題が起きる可能性も...あるかもしれませんね。</p>

<p>　そして、Ｗｉｎｄｏｗｓは西暦１９８０年からの経過年を使っています。ここでもそれプラス０〜９９年までということをやっています。つまり現在のＷｉｎｄｏｗｓは西暦２０８０年問題を抱えているということです。これがＷｉｎｄｏｗｓだけの話かどうかは知りませんが、まだまだ安心はできないかもしれませんね...と脅しておきましょう（ニヤリ）。</p>

<p>　聞いた話によると、平成１０年にプログラムが誤作動するというプログラムもあったそうで、これはもう<font size=+2 color=red>論外</font>ですね。</p>

<hr>

<p>　最後は、ビットフィールドの色々な特徴について触れます。本当は２章に分ければいいのでしょうが、ビットフィールドに２章も割くつもりはないので。</p>

<p>　先ず、ビットフィールドは<font color=red>構造体のメンバの一部であっても使えます</font>。例えば、</p>

<pre>struct BDate
{
    unsigned nYear  : 12;
    unsigned nMonth : 4;
    unsigned nDay   : 5;
    int      nWeekday;
};</pre>

<p>ということもできます。この場合、nYear から nDay までが <font color=red>int のサイズ、もしくはその倍数</font>となります。つまり、３２ビット機であれば、この構造体の全体のサイズは８になります。</p>

<p>　さらに、ビットフィールドは<font color=red>クラスと共用体でも使えます</font>。</p>

<p>　そして、ビットフィールドの<font color=red>アドレスは取得できません</font>。アドレスは<font color=red>バイト単位</font>の通し番号なので、当たり前ですね。</p>

<p>　また、ビットを飛ばすこともできます。</p>

<pre>struct BDate
{
    unsigned nYear    : 12;
    unsigned nMonth   : 4;
    unsigned nDay     : 5;
    <font color=red>unsigned          : 8;</font>
    unsigned nWeekday : 3;
};</pre>

<p>　名前を付けなければ、<font color=red>その部分は飛ばされます</font>。名前なしの変数が作られていると思っても構いません。</p>

<p>　また、<font color=red>int のサイズ以上のサイズを割り当てることはできません</font>。</p>

<pre>struct BDate
{
    <font color=red>unsigned nYear    : 33;</font>  // エラー
    unsigned nMonth   : 4;
    unsigned nDay     : 5;
};</pre>

<p>　そして、<font color=red>int のサイズの境界をまたぐことはできません</font>。</p>

<pre>struct BDate
{
    unsigned nYear    : 30;
    unsigned nMonth   : 4;
    unsigned nDay     : 30;
};</pre>

<p>　nYear のサイズは３０ビットです。int のサイズが３２とすると、あと２ビットしか残っていません。すると、nMonth はここに収まらないので、次の３２ビットの領域に割り当てられます。</p>

<p>　そして、次の nDay は 残り２８ビットの領域に入らないので、さらに次の３２ビット領域に割り当てられます。</p>

<p>　このせいで、一見８バイトに収まりそうなこの構造体のサイズは１２バイトになってしまいます。</p>

<p>　最後に、<font color=red>強制的に次の int のサイズの境界に移すこともできます</font>。</p>

<pre>struct BDate
{
    unsigned nYear    : 12;
    <font color=red>unsigned          : 0;</font>
    unsigned nMonth   : 4;
    <font color=red>unsigned          : 0;</font>
    unsigned nDay     : 5;
};</pre>

<p>　名前のない、サイズ０のビットフィールドを作ろうとする感じですね。こうすると、ここで強制的に次の int のサイズの境界に移ることになります。</p>

<p>　一見４バイトに収まりそうなこの構造体のサイズは、何と１２バイトになります。</p>

<p>　駆け足でしたが、これらのことは何となく頭に入れておく程度でいいでしょう。ビットフィールドを実際に使おうとしたとき、ここを見返したのでいいでしょうね。</p>

<hr>

<p>　それでは、今回の要点です。最後に色々書きましたが、特に重要なのはこれくらいでしょうか。</p>

<font size=+2 color=red>
<ul>
<li>構造体のメンバ変数の後ろに : &lt;ビット数&gt; を書くと、そのメンバ変数の大きさはそのビット数になる。</li>
<li>ビットフィールドの型は unsigned int か signed int か int のみ。</li>
<li>ビットフィールド全体のサイズは int のサイズか、その倍数に揃えられる。</li>
<li>クラス、共用体でも、またはこれらの一部分でも使用できる。</li>
</ul>
</font>
<p><br></p>

<p>　次回は構造体を扱う上で注意しなければならない、とても重要なことをお話しします。同時に面白いマクロも紹介します。それでは。</p>

<hr>

<p align=right><a href="cpp03012.html" target="main">第１２章　名無し</a> | <a href="cpp03014.html" target="main">第１４章　前へならえ</a></p>
<p align=right><font size=-1><i>Last update was done on 2000.8.7</i></font></p>

<p align=right><font size=-1><i>この講座の著作権は<a href="http://www1.kcn.ne.jp/~robe/">ロベール</a>が保有しています</i></font></p>

</body>
</html>
